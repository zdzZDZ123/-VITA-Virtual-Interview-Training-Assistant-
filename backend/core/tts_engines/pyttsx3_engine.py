"""
Pyttsx3 TTSå¼•æ“å®ç° 
ä½¿ç”¨æœ¬åœ°pyttsx3åº“ï¼Œå®Œå…¨ç¦»çº¿ï¼Œä½œä¸ºedge-ttsçš„å¤‡ç”¨æ–¹æ¡ˆ
"""

import asyncio
import tempfile
import os
from typing import Dict, Any
from .base import BaseTTSEngine

try:
    import pyttsx3
    PYTTSX3_AVAILABLE = True
except ImportError:
    PYTTSX3_AVAILABLE = False


class Pyttsx3Engine(BaseTTSEngine):
    """
    Pyttsx3 TTSå¼•æ“å®ç°
    ä½¿ç”¨ç³»ç»Ÿå†…ç½®TTSå¼•æ“ï¼Œå®Œå…¨ç¦»çº¿
    """
    
    name = "pyttsx3"
    priority = 2  # å¤‡ç”¨å¼•æ“ï¼Œä¼˜å…ˆçº§è¾ƒä½
    
    def __init__(self):
        super().__init__()
        self._engine = None
        self._init_engine()
        
        self.logger.info(f"ğŸ”Š Pyttsx3Engine åˆå§‹åŒ– (å¯ç”¨: {PYTTSX3_AVAILABLE})")
    
    def _init_engine(self):
        """åˆå§‹åŒ–pyttsx3å¼•æ“"""
        if not PYTTSX3_AVAILABLE:
            return
        
        try:
            self._engine = pyttsx3.init()
            
            # è®¾ç½®é»˜è®¤å±æ€§
            if self._engine:
                # è®¾ç½®è¯­é€Ÿ (ä¸€èˆ¬èŒƒå›´ 50-300)
                self._engine.setProperty('rate', 180)
                
                # è®¾ç½®éŸ³é‡ (0.0-1.0)
                self._engine.setProperty('volume', 0.9)
                
                # å°è¯•è®¾ç½®ä¸­æ–‡è¯­éŸ³
                voices = self._engine.getProperty('voices')
                if voices:
                    # å¯»æ‰¾ä¸­æ–‡è¯­éŸ³
                    for voice in voices:
                        voice_id = voice.id
                        if any(lang in voice_id.lower() for lang in ['zh', 'chinese', 'mandarin']):
                            self._engine.setProperty('voice', voice_id)
                            break
                    else:
                        # å¦‚æœæ²¡æœ‰ä¸­æ–‡è¯­éŸ³ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨è¯­éŸ³
                        self._engine.setProperty('voice', voices[0].id)
                
                self.logger.info("âœ… Pyttsx3å¼•æ“åˆå§‹åŒ–æˆåŠŸ")
            
        except Exception as e:
            self.logger.warning(f"âš ï¸ Pyttsx3å¼•æ“åˆå§‹åŒ–å¤±è´¥: {e}")
            self._engine = None
    
    def is_available(self) -> bool:
        """æ£€æŸ¥pyttsx3æ˜¯å¦å¯ç”¨"""
        return PYTTSX3_AVAILABLE and self._engine is not None
    
    def get_supported_voices(self) -> Dict[str, str]:
        """è·å–æ”¯æŒçš„å£°éŸ³åˆ—è¡¨"""
        return {
            "nova": "ç³»ç»Ÿé»˜è®¤å¥³å£°",
            "echo": "ç³»ç»Ÿé»˜è®¤ç”·å£°", 
            "alloy": "ç³»ç»Ÿä¸­æ€§å£°éŸ³",
            "system": "ç³»ç»Ÿå½“å‰è¯­éŸ³"
        }
    
    async def synthesize(
        self, 
        text: str, 
        voice: str = "nova", 
        speed: float = 1.0,
        **kwargs
    ) -> bytes:
        """
        ä½¿ç”¨pyttsx3åˆæˆè¯­éŸ³
        
        Args:
            text: è¦åˆæˆçš„æ–‡æœ¬
            voice: å£°éŸ³ç±»å‹ (pyttsx3ä½¿ç”¨ç³»ç»Ÿè¯­éŸ³)
            speed: è¯­é€Ÿå€ç‡
            **kwargs: å…¶ä»–å‚æ•°
            
        Returns:
            WAVæ ¼å¼çš„éŸ³é¢‘æ•°æ®
            
        Raises:
            RuntimeError: å½“pyttsx3ä¸å¯ç”¨æ—¶
            Exception: åˆæˆå¤±è´¥æ—¶
        """
        if not self.is_available():
            raise RuntimeError("pyttsx3 ä¸å¯ç”¨ï¼Œè¯·å®‰è£…: pip install pyttsx3")
        
        # éªŒè¯å’Œæ ‡å‡†åŒ–å‚æ•°
        voice = self.validate_voice(voice)
        speed = self.validate_speed(speed)
        
        self.logger.debug(f"ğŸ”Š Pyttsx3åˆæˆ: voice={voice}, speed={speed}, text_len={len(text)}")
        
        try:
            # è®¾ç½®è¯­é€Ÿ (pyttsx3çš„rateé€šå¸¸åœ¨50-300ä¹‹é—´)
            base_rate = 180
            new_rate = int(base_rate * speed)
            new_rate = max(50, min(400, new_rate))  # é™åˆ¶èŒƒå›´
            self._engine.setProperty('rate', new_rate)
            
            # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as tmp_file:
                tmp_filename = tmp_file.name
            
            try:
                # ä½¿ç”¨asyncioåœ¨çº¿ç¨‹æ± ä¸­è¿è¡ŒåŒæ­¥æ“ä½œ
                await asyncio.get_running_loop().run_in_executor(
                    None, 
                    self._synthesize_sync, 
                    text, 
                    tmp_filename
                )
                
                # è¯»å–ç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶
                with open(tmp_filename, 'rb') as f:
                    audio_data = f.read()
                
                if not audio_data:
                    raise Exception("ç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶ä¸ºç©º")
                
                self.logger.debug(f"âœ… Pyttsx3åˆæˆæˆåŠŸ: {len(audio_data)} bytes")
                return audio_data
                
            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                if os.path.exists(tmp_filename):
                    os.unlink(tmp_filename)
                    
        except Exception as e:
            self.logger.error(f"âŒ Pyttsx3åˆæˆå¤±è´¥: {e}")
            raise Exception(f"Pyttsx3åˆæˆå¤±è´¥: {e}")
    
    def _synthesize_sync(self, text: str, output_file: str):
        """åŒæ­¥çš„è¯­éŸ³åˆæˆæ–¹æ³•"""
        try:
            # ä¿å­˜åˆ°æ–‡ä»¶
            self._engine.save_to_file(text, output_file)
            
            # è¿è¡Œäº‹ä»¶å¾ªç¯ç­‰å¾…å®Œæˆ
            self._engine.runAndWait()
            
        except Exception as e:
            raise Exception(f"Pyttsx3åŒæ­¥åˆæˆå¤±è´¥: {e}")
    
    def __REMOVED_API_KEY__(self) -> Dict[str, Any]:
        """
        è·å–ç³»ç»Ÿå¯ç”¨çš„è¯­éŸ³åˆ—è¡¨
        
        Returns:
            ç³»ç»Ÿè¯­éŸ³çš„è¯¦ç»†ä¿¡æ¯
        """
        if not self.is_available():
            return {}
        
        try:
            voices = self._engine.getProperty('voices')
            
            voice_list = []
            for i, voice in enumerate(voices):
                voice_info = {
                    "id": voice.id,
                    "name": voice.name,
                    "age": getattr(voice, 'age', 'Unknown'),
                    "gender": getattr(voice, 'gender', 'Unknown'),
                    "languages": getattr(voice, 'languages', [])
                }
                voice_list.append(voice_info)
            
            return {
                "voices": voice_list,
                "total_count": len(voice_list),
                "current_voice": self._engine.getProperty('voice')
            }
            
        except Exception as e:
            self.logger.error(f"âŒ è·å–ç³»ç»Ÿè¯­éŸ³åˆ—è¡¨å¤±è´¥: {e}")
            return {}
    
    def set_voice_by_language(self, language: str = "zh") -> bool:
        """
        æ ¹æ®è¯­è¨€è®¾ç½®åˆé€‚çš„è¯­éŸ³
        
        Args:
            language: è¯­è¨€ä»£ç  (zh, en)
            
        Returns:
            æ˜¯å¦è®¾ç½®æˆåŠŸ
        """
        if not self.is_available():
            return False
        
        try:
            voices = self._engine.getProperty('voices')
            
            if language.startswith("zh"):
                # å¯»æ‰¾ä¸­æ–‡è¯­éŸ³
                keywords = ['zh', 'chinese', 'mandarin', 'ä¸­æ–‡']
            elif language.startswith("en"):
                # å¯»æ‰¾è‹±æ–‡è¯­éŸ³
                keywords = ['en', 'english', 'us', 'uk']
            else:
                return False
            
            for voice in voices:
                voice_id = voice.id.lower()
                voice_name = voice.name.lower()
                
                if any(keyword in voice_id or keyword in voice_name for keyword in keywords):
                    self._engine.setProperty('voice', voice.id)
                    self.logger.info(f"âœ… å·²è®¾ç½®è¯­éŸ³: {voice.name}")
                    return True
            
            self.logger.warning(f"âš ï¸ æœªæ‰¾åˆ°{language}è¯­éŸ³ï¼Œä½¿ç”¨é»˜è®¤è¯­éŸ³")
            return False
            
        except Exception as e:
            self.logger.error(f"âŒ è®¾ç½®è¯­éŸ³å¤±è´¥: {e}")
            return False 